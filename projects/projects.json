{"raytracing":{"name":"Raytracing","img":"/projects/raytracing/thumbnail.png","desc":"Render realistic 3D scenes by simulating light rays","html":"<h2>What are Raytracers?</h2>\n<div>\n    <img class = 'img' src = '/projects/raytracing/thumbnail.png' style='margin-top: 4px;'>\n    <p>\n        Raytracers are a method of rendering 3D scenes. They're many\n        different types of 3D rendering and each one has it's own\n        advantages and disadvantages. The primary advantage of raytracers\n        is that they are highly realistic and are often used to create\n        photorealistic images. They achieve this photorealism by\n        simulating the paths of thousands of individual light rays. This\n        gives it its name since it's tracing where rays go. However,\n        this accuracy comes at a computational cost; it takes a long\n        time for images to be rendered with enough resolution to look\n        good. Despite that, recent advancements in AI have allowed\n        raytracing to work in real time while still maintaining the\n        same quality. We won't cover how the AI system works, but we\n        will go over how the base concepts of raytracing.\n    </p>\n</div>\n<br>\n<h2>How Do They Work?</h2>\n<p>\n    We do everything in reverse in the name of <i><strong>speed</strong>.</i> The Sun\n    produces light,<sup>[<i>citation needed</i>]</sup> but the vast majority of that light begins\n    its long lasting pilgrimage into the lonely depths of space, never to be seen by human eyes.\n    In other words, we don't care about it. If we were to simuluate all of that\n    light, we'd be wasting a lot of computational power. Instead, what we do in the 3D\n    rendering community is shoot light out of the camera and see what it hits (that's\n    right, we've got <i>lazer eyes</i>). The light rays that we cast out of the camera\n    will only contribute to the final image if they hit a light source, but they're much\n    more likely to hit a light source than light coming from a light source to hit the camera.\n</p>\n<p>\n    Now that we've established the back-to-front nature of raytracing, I have a confession to make.\n    Most of this article is actually all a lie. There's an amazing resource that is\n    significantly better than almost anything else on the internet, so rather than\n    try and fail to surpass it, I'm going to direct you\n    to this wonderful resource: <a href='https://raytracing.github.io/' target='_blank'>Ray Tracing in One Weekend</a>.\n    I think it does have a shortcoming, which is that it doesn't explain how\n    ray-sphere intersections work very well, so that is what the rest of this\n    article consists of. It's not necessarily needed to make a raytracer, but it\n    is a fundamental part of it, which doesn't make much sense at first.\n</p>\n<p>\n    To start out, the equation for a sphere centered at the origin is <m-el>\\(x^{2}+y^{2}+z^{2}=r^{2}\\)</m-el>,\n    where <m-el>\\(x\\)</m-el>, <m-el>\\(y\\)</m-el>, and <m-el>\\(z\\)</m-el> are coordinates\n    and <m-el>\\(r\\)</m-el> is the radius. However, since we'll be working in vectors,\n    we can simply write this as <m-el>\\(S\\cdot S=r^{2}\\)</m-el>. The equation for a ray\n    is <m-el>\\(A+tB\\)</m-el>. <m-el>\\(A\\)</m-el> is a vector representing the start of\n    the ray, <m-el>\\(B\\)</m-el> is a vector pointing in the direction of the ray, and \n    t is a scalar which represents how far along the ray a point is. To begin our derivation,\n    it helps to define out goal a bit more. We want to find the intersection of a sphere\n    and a ray, but what that really means, is that we want to find a point that is both\n    on the sphere and on the ray. What we can do now is plug the equation for our\n    ray into <m-el>\\(S\\)</m-el> in the equation for a sphere as our starting equation. When the equation is\n    true, the point is both on the ray and on the sphere, which is what we want! This\n    is our current equation:\n</p>\n<m-el>\\[\\left(A+tB\\right)\\cdot\\left(A+tB\\right)=r^{2}\\]</m-el>\n<p>\n    When doing the\n    calculations, the values of the sphere, the starting point of the ray, and the\n    direction will all be defined by us, but we will want to find out how far along\n    the ray the point that intersects the sphere is. So, we want to solve for <m-el>\\(t\\)</m-el>.\n    Currently, <m-el>\\(t\\)</m-el> is encased in those pesky parentheses, so the next\n    step is to&nbsp;&nbsp;e x p a n d&nbsp;&nbsp;using the laws of vector algebra:\n</p>\n<m-el>\\[t^{2}B\\cdot B+2tA\\cdot B+A\\cdot A=r^{2}\\]</m-el>\n<p>\n    Now, something that you might notice which is pretty interesting is that we have a\n    quadratic equation in terms of <m-el>\\(t\\)</m-el>, so we can use the quadratic\n    formula to solve for <m-el>\\(t\\)</m-el> after a bit of rearranging:\n</p>\n<m-el>\\[t^{2}B\\cdot B+2tA\\cdot B+A\\cdot A-r^{2}=0\\]</m-el>\n<m-el>\\[t=\\frac{-2A\\cdot B\\pm\\sqrt{\\left(2A\\cdot B\\right)^{2}-4\\left(B\\cdot B\\right)\\left(A\\cdot A-r^{2}\\right)}}{2\\left(B\\cdot B\\right)}\\]</m-el>\n<p>\n    We now know what <m-el>\\(t\\)</m-el> is! Now, that isn't a very friendly looking equation, but computers don't care, and\n    many of the terms are repeated, allowing you to store them as variables which\n    simplifies the equation a lot. An observant reader may have noticed that our\n    derivation only works with spheres centered at the origin, but we want the freedom\n    to choose where are spheres go. This presents an issue, which can be solved in two\n    main ways: rederiving with other positions in mind or shifting our reference frame.\n    In the name of consistency, we're going to shift our reference frame (most other\n    collision functions, like those of triangles, which are useful as you get more\n    advanced, require shifting reference frames, so it's good to get an understanding\n    of how it works sooner rather than later). How it works is that, before we use\n    our equation, we'll shift the sphere and the ray by some amount so that the sphere\n    is actually on the origin. Once we have the point on the sphere relative to the\n    origin, we can shift the scene and the intersection point back to where they\n    originally were. This can be done by subtracing the sphere's coordinates and then\n    adding the sphere's coordinate after the intersection point is found.\n</p>\n<p>\n    A small but important optimization is that we can use the determinant (the expression under the \n    square root) to figure out a few more things about the intersection point. We won't\n    always have a single intersection; sometimes, the ray will completely miss the sphere\n    and other times, the ray will intersect the sphere twice (once on the way in and once\n    on the way out). The number of intersections is determined by the determinant. If it\n    is less than 0, then there won't be any intersections. If it is precisely equal to\n    0, then there will be one intersection. If it is greater than 0, then there will be\n    two intersections. This is helpful because we can stop the function before we get\n    to the square root which is very computationally expensive in most cases. You might\n    wonder what to do if there are two intersection points. In that case, you choose\n    the closest one which is the value of <m-el>\\(t\\)</m-el> when subtracting instead\n    of adding with the plus or minus part of the quadratic formula.\n</p>\n<br>\n<h2 id='further-reading'>Further Reading</h2>\n<ul id='further-reading-list'>\n    <li> \n        <a href='https://raytracing.github.io/' target='_blank'>Ray Tracing in One Weekend</a> - Peter Shirley et al.\n        One of the best sources for raytracing on the internet.\n    </li>\n    <li>\n        <a href='https://www.youtube.com/watch?v=Qz0KTGYJtUk&t=806s' target='_blank'>Coding Adventure: Ray Tracingt</a> - Sebastian Lague.\n        Provides an overview of ray tracing and goes into some of the\n        math more.\n    </li>\n</ul>"},"penrose-tilings":{"name":"Penrose Tilings","img":"/projects/penrose-tilings/penrose-background.png","desc":"Create the geometric tilings found on this webpage","html":"<h2>What are Penrose Tilings?</h2>\n<p>\n    Let's say you have an infinite amount of tiles of a certain\n    shape, like a square. You can slide them together in a grid on a plane (an infinte flat surface)\n    and that grid will go on without stopping. The same goes for\n    triangles and hexagons. These grids are repeating which means\n    that if you have two copies of the grid, one on top of the\n    other, you can slide one around and it will line up perfectly\n    with the other. This is called a <i>periodic</i> tiling.\n    Other shapes don't have this special infinite\n    tiling property, like pentagons. However, if you allow more\n    shapes than just the pentagon, you can tile the grid. A\n    question you might ask is, is it possible to create a finite\n    number of tiles that tile the plane, but <i>don't</i> tile it\n    periodically? In other words, is it possible to create an\n    infinite tiling that never repeats? The answer is actually yes!\n    The first set of tiles that people found had over 1,000 different\n    tiles in it and were called Wang Tiles. Other researchers\n    started trying to reduce the number of types of tiles and\n    slowly worked it down to a few hundred, and then down to six.\n    Now the protagonist of this story enters! Robert Penrose managed\n    to reduce the number of types of tiles to just two shapes: a\n    thick and a thin rhombus (affectionately called by mathematicians\n    \"rhombs\"). With those two tiles, you can create a pattern that\n    never repeats and yet goes on forever. This type of pattern is\n    called a penrose tiling and are what we'll be exploring here.\n    They've also been used in Islamic tilings.\n</p>\n<p>\n    There are variants of penrose tilings that use more than just\n    two types of tiles, such as the one depicted below. They are\n    still aperiodic and often look better, but it is worth noting\n    that not all images that are on this webpage are \"true\" penrose\n    tiles.\n</p>\n<div class='img-container'>\n    <img class='big-img' alt='An example of a penrose tiling variant used extensively across this website' src='/projects/penrose-tilings/penrose-background.png' style='max-width: 500px; width: 60%;'>\n    <span class='caption'>Penrose tilings are used all across this website.</span>\n</div>\n<h2>How are They Created?</h2>\n<p>\n    To start off, a key concept is that there is an alternate representation of a\n    tiling. For a regular penrose tiling (i.e. only two tiles), that\n    representation is something called a pentagrid. A pentagrid is\n    where you have a 5 sets of parallel lines which are offset from\n    each other by 72°, as seen in the picture below.\n</p>\n<div class='img-container'>\n    <img class='big-img' alt='A pentagrid' src='/projects/penrose-tilings/pentagrid-better-colors.png' style='max-width: 180px; width: 40%;'>\n</div>\n<p>\n    It contains the\n    exact same information as the actual tiling, but just in another\n    form (you can think of it like how 9 in base ten is the same as\n    1001 in binary). Each intersection represents a single tile in the completed Penrose tiling. The\n    number and angles of the lines that intersect encode properties of\n    the tile. The shape that the intersection represents has 2 times\n    the number of lines that intersect. The angles of the lines dictate\n    how the overall rotation of the shape as well as the angles of the\n    edges. The method of creating a pentagrids is\n    rather peculiar. Essentially, you need to use an equation for a\n    line that is rarely ever used. It draws the line tangent to a circle\n    with a radius <m-el>\\(r\\)</m-el> at the point\n    <m-el>\\(\\theta\\)</m-el> radians around the circle.\n    The following is the formula for that equation of a line.\n</p>\n<m-el>\\[x\\sin\\left(\\theta+\\frac{\\pi}{2}\\right)=y\\cos\\left(\\theta+\\frac{\\pi}{2}\\right)+r\\]</m-el>\n<p>\n    Using this formula, you can create 5 lines with <m-el>\\(r = 1\\)</m-el>,\n    each rotated by an integer multiple of 72° (in radians, they would\n    be rotated multiples of <m-el>\\(\\frac{2\\pi}{5}\\)</m-el>).\n    Then, repeat this for as many increasing integers of <m-el>\\(r\\)</m-el>\n    as you would like. In other words, <m-el>\\(r=1,2,3,4...\\)</m-el> etc.\n    The more times you repeat this, the larger the eventual tiling will be.\n    This equation has one small issue, though. Right now, if you follow this\n    process exactly, the resulting pentagrid will have 5 lines intersecting\n    at the center. If we want to create a \"true\" penrose tiling, this will\n    create a third type of tile, which we don't want. In order to fix that,\n    we can simply add an offset from 0 to 1 to the lefthand side of the\n    equation, like so (notice the <m-el>\\(o\\)</m-el>):\n</p>\n<m-el>\\[x\\sin\\left(\\theta+\\frac{\\pi}{2}\\right)+o=y\\cos\\left(\\theta+\\frac{\\pi}{2}\\right)+r\\]</m-el>\n<p>\n    Now that we have a pentagrid, the next step is to translate the pentagrid\n    into a penrose tiling. If you remember, each intersection translates to a\n    tile and the properties of the lines translate to the properties of the\n    tile, like number of sides and rotation. The nice this is, we don't have to\n    worry that much about the specifics, because the pentagrid also carries the\n    information on exactly how the vertices should be placed. That information\n    is held within the blank areas around the lines, as each blank area actually\n    represents a vertex of a shape (if you think about it, this leads to why\n    the tiles are guaranteed to fit so nicely together. Since multiple intersections\n    are bordering the same blank space, they all will share the same vertex).\n    Zooming in on a single intersection, each of the colored regions translates to a vertex of\n    the intersection's shape:\n</p>\n<div class='img-container'>\n    <img class='big-img' alt='A pentagrid' src='/projects/penrose-tilings/pentagrid-region-diagram.png' style='max-width: 180px; width: 40%;'>\n</div>\n<p>\n    As you can see, four regions border the intersection in the center, meaning that the\n    resulting shape will have four vertices, and therefore, will be a quadrilateral.\n    Up until now, we've been fairly abstract about how the whole translation\n    process will work. The secret is a special formula developed by de Bruijn:\n</p>\n<m-el>\\[V\\left(\\overrightarrow{x}\\right)=\\sum_{j=0}^{4}K_{j}\\left(\\overrightarrow{x}\\right)\\overrightarrow{v_{j}}\\]</m-el>\n<p>\n    Since there's a lot going on, let's break it down. The function <m-el>\\(V\\)</m-el>\n    takes in a position, <m-el>\\(\\overrightarrow{x}\\)</m-el>, and\n    outputs a vertex of a shape in the eventual tiling. <m-el>\\(V(\\overrightarrow{x})\\)</m-el>\n    will always output the same point for inputs inside of the same region of the pentagrid.\n    <m-el>\\(\\overrightarrow{x}\\)</m-el> and <m-el>\\(\\overrightarrow{v}\\)</m-el>\n    are represented as vectors. Sums are inclusive, meaning that, in this case,\n    <m-el>\\(j\\)</m-el> has 5 values: 0, 1, 2, 3, and 4. \n    <m-el>\\(\\overrightarrow{v_{j}}\\)</m-el> is a unit vector with\n    an angle of <m-el>\\(\\frac{2\\pi j}{5}\\)</m-el> radians.\n    <m-el>\\(K_{j}\\left(\\overrightarrow{x}\\right)\\)</m-el> is defined as\n    the following:\n</p>\n<m-el>\\[K_{j}\\left(\\overrightarrow{x}\\right)=\\operatorname{ceil}\\left(\\overrightarrow{x}\\cdot \\overrightarrow{v}+o\\right)\\]</m-el>\n<p>\n    <m-el>\\(\\operatorname{ceil}\\)</m-el> is a function which rounds up\n    whatever its input is and <m-el>\\(o\\)</m-el> is the offset for the pentagrid.\n    Now that we have the formula defined, we can talk about how to use it. At each\n    intersection, simply find a point in each neighboring reigon and run that point\n    through the formula. Take the new vertices outputted by the formula and set them\n    to be the vertices of a tile. Repeat this process for as many intersections as you\n    would like to create differently sized tilings. An issue still remains. There might\n    be tiles floating off in space, disconnected from the main bulk of tiles. To get rid\n    of them, you can only create tiles that are a less than a certain distance from the\n    center. Now, you can draw the tiles and bask in the glory of your newly formed\n    penrose tiling!\n</p>\n<p>\n    <strong>But wait! There's <i>more!</i></strong> What you have now is a \"true\"\n    penrose tiling, but we're interested in exploring the falsehoods of this reality.\n    So, how can the aforementioned variants of penrose tilings be created? It's actually\n    pretty simple. All penrose tilings and their variants are rotationally symmetric,\n    meaning that you can rotate it about its center and it'll line up with itself. To\n    create variants, you need to increate the number of symmetries it has. This can simply\n    be done by adding more lines to the pentagrid. Just make sure that the rotations of\n    the lines from each other are changed from <m-el>\\(\\frac{2\\pi}{5}\\)</m-el> to\n    <m-el>\\(\\frac{2\\pi}{s}\\)</m-el>, where <m-el>\\(s\\)</m-el> is the number of symmetries.\n    De Bruijn's formula still works when there are more symmetries, but you're code probably\n    doesn't, so remember to go through and change parts that are depended on symmetries, like\n    the number and direction of the unit vectors as well as the upper bound of the sum in\n    de Bruijn's formula. Another thing that might need adjusting is how you handle the\n    intersection of multiple lines. Make sure it's compatible with more than two lines\n    at an intersection (for the vocabulary nerds like me, this is called a \"point of\n    concurrency\"). An added benefit is that the offset can now be set to 0 without issue\n    which often looks cool.\n</p>\n<br>\n<h2>Helpful Tips</h2>\n<ul>\n    <li>\n        If your tiles' vertices seem to be in the right place, but in a wacky order,\n        try sorting the lines by their angle first.\n    </li>\n    <li>\n        If you want to be able to store and differentiate different types of tiles\n        for coloring and other effects, you can find their area. Each type of tile\n        should have its own area. Remember to round it to a couple decimal places,\n        so floating point errors won't get in the way.\n    </li>\n    <li>\n        The sizes of the regions in pentagrids get what mathematicians say is \"arbitrarily\n        small\". In other words, they get tiny. Really tiny. Make sure that if you find points\n        in regions next to intersections by taking a step in the direction of the region from\n        the intersection, make sure that step is small enough; otherwise, you can go too far\n        and enter another region, which you don't want.\n    </li>\n    <li>\n        Often, lag will be caused by duplicated lines or tiles, so checking for those and\n        removing them can help. \n    </li>\n</ul>\n<br>\n<h2>Further Reading</h2>\n<ul>\n    <li>\n        <a href='https://www.youtube.com/watch?v=-eqdj63nEr4' target='_blank'>Why Penrose Tiles Never Repeat</a> - minutephysics.\n        It's gives an excellent overview of the tilings as well as some intuitions about why the tilings act\n        how they do. It isn't too rigorous, though.\n    </li>\n    <li>\n        <a href='https://www.youtube.com/watch?v=48sCx-wBs34' target='_blank'>The Infinite Pattern That Never Repeats</a> - Veritasium.\n        Provides an overview of how the tilings work and give a lot of interesting facts about them.\n    </li>\n    <li>\n        <a href='http://www.neverendingbooks.org/tag/penrose-tiling' target='_blank'>de Bruijn's pentagrids</a> - LIEVENLB.\n        An article which goes over how the formulas for translating the pentagrid works as well\n        as other facts and relations between other mathematical ideas.\n    </li>\n    <li>\n        <a href='https://web.williams.edu/Mathematics/sjmiller/public_html/hudson/HRUMC-Mowry&Shukla_Pentagrids%20and%20Penrose.pdf' target='_blank'>Pentagrids and Penrose Tilings</a> - Stacy Mowry and Shriya Shukla\n        Details a different slightly way of using de Bruijn's formula.\n    </li>\n    <li>\n        <a href='https://www.math.brown.edu/reschwar/M272/pentagrid.pdf' target='_blank'>Algebraic theory of Penrose's non-periodic tilings of the plane</a> - N.G. de Bruijn\n        De Bruijn's paper! It's very thorough and is the basis of almost all of the current methods.\n        It's unfortunately not the most understandable to the average reader.\n    </li>\n</ul>"},"newtons-fractal":{"name":"Newton's Fractal","img":"/projects/newtons-fractal/thumbnail.png","desc":"Use Newton's method to create an iconic fractal"},"life":{"name":"Conway's Game of Life","img":"/projects/conways-game-of-life/thumbnail.png","desc":"Create cellular automata that mimic life","html":"<h2>What is Conway's Game of Life?</h2>\n<div>\n    <img class = 'img' src = '/projects/conways-game-of-life/thumbnail.png'>\n    <p>\n        Conway's Game of Life is something called a <i>cellular automata</i>\n        which tries to mimic how life works through a simple set of rules.\n        A cellular automata is made up of a grid of tiles, called cells, each\n        with a state. In this case, the only possible states are either alive\n        or dead. A cell will change its state from alive to dead and vice versa\n        based on the number of living cells surrounding it.\n        Different cellular automata (like Day and Night, which is another project\n        you can try out) are defined by how different numbers of living cells\n        change a cell's state as well as how many states exist. In this case,\n        if there is a cell with 2-3 living neighbors, then the cell survives\n        on to the next generation, but any living cell with more than 3 living neighbors\n        will die and change state. This mimics overpopulation. Likewise, any\n        cell with <i>fewer</i> than 2 living neighbors will die which represents\n        underpopulation. There is just one last rule. If a dead cell has\n        precisely 3 living neighbors, it will become a living cell again. This\n        mimics reproduction, completing the cycle of life.\n    </p>\n</div>\n<br>\n<h2>Interesting Patterns</h2>\n<div>\n    <p>\n        <img class = 'img' style = 'position: relative; image-rendering: pixelated;' src = '/projects/conways-game-of-life/glider.png'>\n        One of the joys of this project is setting the initial states of the cells\n        to be a certain pattern and watching it evolve. You might find that some of\n        the starting patterns will have special properties. Some of the more common\n        special properties (ignore the oxymoron; they're important to notice but\n        often irrelevant (haha)) are sorted into three groups: still lifes, oscillators,\n        and spaceships. Still lifes are unchanging, while oscillators repeat some number\n        of patterns indefinitely. Spaceships are like oscillators, because they always\n        return to a certain pattern, but they also move across the grid of cells. On\n        the right is arguably the simplest spaceship. There are still very many more\n        interesting starting patterns, which you can find in the website listed in the\n        <a href = '#further-reading'>further reading</a> section.\n    </p>\n</div>\n<br>\n<h2>Common Pitfalls</h2>\n<p>\n    The most common area where people go wrong is to update the grid of cells\n    as you're looking at it. Essentially, you have a copy of the original grid\n    which you reference in order to know the number of living neighbors around\n    a cell and you update the original while looking at the copy. This prevents\n    you from trying to reference parts of the grid which are already part of the\n    next generation. The incorrect version is called Naive Life.\n</p>\n<br>\n<h2>Background</h2>\n<p>\n    Conway's Game of Life is often shortened to The Game of Life, or just Life.\n    As you might have guessed, it was invented by John Conway. He called\n    it a 0 player game since all you have to do is input a pattern and the\n    game will play itself until it reaches a predictable state. An interesting\n    concept that has a connection to Conway's Game of Life is the idea of\n    Turing Completeness. If a system is Turing complete, it is able to solve\n    any logical problem that can be solved (it might surprise you that some\n    problems in math and programming literally <i>cannot</i> be solved). Conway's\n    Game of Life just so happens to be Turing complete, just like a lot of\n    programming languages and even popular video games. What that means is\n    that the Game of Life can technically solve anything that you can. This\n    can be taken to the extreme, and people have even coded the\n    <a href = 'https://www.youtube.com/watch?v=xP5-iIeKXE8' target = '_blank'>Game of Life inside of itself</a>!\n</p>\n<br>\n<h2 id = 'further-reading'>Further Reading</h2>\n<ul id = 'further-reading-list'>\n    <li><a href = 'https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life' target='_blank'>Conway's Game of Life</a> - Wikipedia. A very good overview of what Conway's Game of Life is, its history, and other details.</li>\n</ul>"},"lorenz-attractor":{"desc":"Explore one of the first demonstrations of chaos","img":"/projects/lorenz-attractor/thumbnail.png","name":"Lorenz Attractor","html":"                                        <h2>What is a Lorenz Attractor?</h2>\n<img class = 'img' src = '/projects/lorenz-attractor/thumbnail.png'>\n<p>\n    Edward Lorenz at one point was trying to model a part of how air moves in the\n    atmosphere when the air is heated near the ground and cooled at the top of the atmosphere (this is called\n    atmospheric convection, but that's beside the point). He ran the simulation\n    on a computer and had a printer print out the current state of the simulation\n    as time went on. At one point, he decided that he wanted to run a simulation\n    of a certain initial state again, but he decided to restart the run halfway through\n    with one of the sets of values of the previous simulation. What he found was\n    that the results were entirely different! How could this be? It turned out that\n    the printer printed fewer decimal places than the computer used when simulating,\n    so, when Lorenz inputted the printer results back into the simulation, the\n    conditions he inputted were ever so slightly different from the conditions\n    that the computer actually stored. Even though the difference in conditions\n    was <i>tiny</i>, the effect that it had was extremely large. This idea that\n    small effects can have enormous consequences is called the Butterfly Effect.\n    Coincidentally, as you can see on the right, Lorenz Attractors look similar\n    to the wings of a butterfly.\n</p>\n<br>\n<h2>How are They Created?</h2>\n<p>\n    Lorenz's simulation was originally made up of 12 equations with 12 variables,\n    but he managed to simplify them down to just 3 equations with 3 variables.\n    Since there are only 3 variables, we can plot them in 3D space! Note that\n    there are also constants, but those don't change which means we don't have\n    to include them when plotting. These are the equations:\n</p>\n<m-el>\\[\\frac{dx}{dt}=\\sigma\\left(y-x\\right)\\]</m-el>\n<m-el>\\[\\frac{dy}{dt}=x\\left(\\rho-z\\right)-y\\]</m-el>\n<m-el>\\[\\frac{dz}{dt}=xy-\\beta z\\]</m-el>\n<p>\n    These look fairly complex, especially if you aren't familiar with the notation,\n    but they're actually really simple. Normal equations, like <m-el>\\(y=2x\\)</m-el>,\n    for example, mean things like \"when <m-el>\\(x\\)</m-el> equals <m-el>\\(2\\)</m-el>, <m-el>\\(y\\)</m-el>\n    equals <m-el>\\(4\\)</m-el>\", but these are a bit different. In this case, these\n    equations say to add, rather than to set. So, each frame of the simulation\n    <m-el>\\(\\sigma\\left(y-x\\right)\\)</m-el> is added to <m-el>\\(x\\)</m-el>. Going with\n    the same idea, <m-el>\\(x\\left(\\rho-z\\right)-y\\)</m-el> is added to <m-el>\\(y\\)</m-el>, and you can probably\n    guess what gets added to <m-el>\\(z\\)</m-el>. For those who are curious, these types\n    of equations which are based on change are called differential equations, and are\n    part of calculus (so, if you understood that explanation, then you understand a bit\n    of calculus!). You might find that, when making the simulation, you need to scale\n    down what is added to each variable each frame; otherwise, the system of equations\n    could blow up and the variables will go off to infinity.\n</p>\n<p>\n    Right now, we haven't set the values of <m-el>\\(\\sigma\\)</m-el>, <m-el>\\(\\rho\\)</m-el>,\n    and <m-el>\\(\\beta\\)</m-el>. The conventional values for them are 10, 28, and 8/3,\n    respectively. These will create the two lobes of the attractor, but other close\n    values will work as well. A lot of combinations will spiral into the center, while\n    others will spread out.\n</p>\n<p>\n    After the equations are updated each frame, graph their new positions in 3D\n    space. Something that's interesting to do is to graph multiple points which start off\n    very close together but not exactly in the same position and let the simulation run.\n    After a bit, the points will start to diverge and go on their own paths and won't\n    ever perfectly meet up with their companions, which is a very common demonstration\n    of the butterfly effect happening in real time.\n    How to render objects in 3D won't be covered here because the methods to do so\n    vary a lot depending on which language you're using. However, generally, it isn't to\n    hard to do as there are many libraries for a vast array of languages which make\n    drawing things in 3D much easier.\n</p>\n<br>\n<h2>Demo: <a href='/projects/lorenz-attractor/lorenz-attractor.html' target='_blank'>Here</a></h2>\n<p>\n    Use the W, A, S, and D keys to move around horizontally. Use the space and shift keys\n    to move vertically and use the mouse to look around.\n</p>\n<br>\n<h2 id = 'further-reading'>Further Reading</h2>\n<ul id = 'further-reading-list'>\n    <li>\n        <a href='https://en.wikipedia.org/wiki/Lorenz_system' target='_blank'>Lorenz system</a> - Wikipedia.\n        Thoroughly covers the mathematics and other interesting facts.\n    </li>\n    <li>\n        <a href='https://www.youtube.com/watch?v=fDek6cYijxI' target='_blank'>Chaos: The Science of the Butterfly Effect</a> - Veritasium.\n        Talks about the more general theories of chaos and mentions the background information about\n        the attractor\n    </li>\n</ul>"},"domain-warping":{"desc":"A technique used for natural textures and math","img":"/projects/domain-warping/thumbnail.png","name":"Domain Warping","html":"<h2>What is Domain Warping?</h2>\n<p>\n    <img class = 'img' src = '/projects/domain-warping/thumbnail.png' style='width: 230px;'>\n    Using the tried and true method of \"if you don't understand a\n    technical term, say it backwards, add grammar, and\n    maybe another word\", we can deduce that domain warping is where\n    you warp the domain of a function (if you don't believe the\n    rule I proposed, take GPU; it stands for graphics processing unit.\n    What does it do? Well, it's a unit on a computer which\n    processes graphics). Essentially, how it works is that you have\n    some sort of function, like <m-el>\\(f(x)\\)</m-el>, and another\n    function <m-el>\\(b(x)\\)</m-el> which stays relatively close to\n    zero, you can compose, add them, multiply them, etc. them\n    to affect the output of. If you repeat this a couple of times\n    and add or multiply some values, then you can get\n    interesting effects like the image to the right. However, you\n    might be wondering why this is notable (apart from just looking\n    cool, of course). Domain warping can be used to create natural\n    and complex textures which resemble gasses and liquids. They\n    can be used in video games to look like gas giant planets.\n    In addition to that, domain warping is also used to take an\n    equation for a shape, like a circle or torus (donut), and\n    transform it in some way. These transformations can be almost\n    anything; you can make a shape wiggly or event twisted, if you're\n    working in 3D.\n</p>\n<br>\n<h2>How are Textures Created?</h2>\n<p>\n    <m-el>\\(f\\)</m-el> and <m-el>\\(b\\)</m-el> can be almost any\n    function, but generally continuous functions look the best.\n    As mentioned before, you also want <m-el>\\(b\\)</m-el> to\n    stay close to zero. For this article, we'll use something\n    called noise for both <m-el>\\(f\\)</m-el> and <m-el>\\(b\\)</m-el>. For those who don't know, noise is essentially\n    a way of creating random numbers that don't have jagged changes\n    and change smoothly. You can think of it as taking random numbers,\n    connecting them with lines, and then smoothing out where those line connect.\n    On the left are purly random numbers connected and values generated\n    by noise are on the right:\n</p>\n<div class='img-container'>\n    <img class='big-img' src='/projects/domain-warping/random-v-noise.png' style='max-width: 500px; width: 60%;' alt='A comparison of random numbers and numbers generated by noise'>\n    <span class='caption'>Random numbers are jagged and noise is smooth</span>\n</div>\n<p>\n    The example above is a 1D example. because there's only one input, <m-el>\\(x\\)</m-el>. To make images like\n    the one that are here, we want 2D noise, which has two input, <m-el>\\(y\\)</m-el>, and <m-el>\\(y\\)</m-el>.\n    Both dimensions of noise only have one output, so the dimension of the noise is determined\n    by how many inputs it has. This is what 2D noise looks like:\n</p>\n<div class='img-container'>\n    <img class='big-img' src='/projects/domain-warping/2D-noise.png' style='max-width: 500px; width: 60%;' alt='2D noise'>\n</div>\n<p>\n    Restating what was said before, simply combine the noise functions with\n    offsets and scaling until you achieve an image that you like. Additionally,\n    if you want to add some sort of animation, a good idea is to add or multiply\n    values by the time as part of your offsets and scaling. The reason why this\n    explanation is so vague is because you can do almost anything that you want\n    to the functions, and it will look at least somewhat interesting.\n</p>\n<br>\n<div style='display: flex; flex-direction: column; float: right;'>\n    <img class = 'img' src = '/projects/domain-warping/beauteous-circle.png' alt='A truly pulchritudinous circle'>\n    <img class = 'img' src = '/projects/domain-warping/warped-beauteous-circle.png' alt='A warped circle, emanating pulchritude'>\n</div>\n<h2>How are Transformations Created?</h2>\n<p>\n    Let's say you have a shape which you've defined with some sort of math, like the\n    beauteous circle on the right (top). It's defined by <m-el>\\(x^{2}+y^{2}=r^{2}\\)</m-el>, with <m-el>\\(r\\)</m-el> being the radius.\n    Very similarly to how the texture method works, you can simply warp the values of\n    <m-el>\\(x\\)</m-el> and <m-el>\\(y\\)</m-el> slightly to change the shape of it.\n    Again, this is vague because the warping can be many things. Simply adding a\n    sine wave to the x coordinate before putting it into  the circle equation creates the image on the right (bottom).\n</p>\n<br>\n<h2>Demos: <a href='/projects/domain-warping/textures.html' target='_blank'>Textures</a> and <a href='/projects/domain-warping/transformations.html' target='_blank'>Transformations</a></h2>\n<br>\n<h2>Further Reading</h2>\n<ul>\n    <li>\n        <a href='https://iquilezles.org/articles/warp/' target='_blank'>Domain Warping</a> - Inigo Quilez.\n        Goes further in-depth about how to code the texture version, especially in GLSL and WebGL.\n    </li>\n</ul>"},"mandelbrot":{"desc":"Learn how to create the most iconic fractal","img":"/projects/mandelbrot/thumbnail.png","name":"The Mandelbrot Set","html":"<h2>What is the Mandelbrot Set?</h2>\n<p>\n    <img class = 'img' src = '/projects/mandelbrot/thumbnail.png'>\n    The Mandelbrot Set is a fractal, meaning that it has an infinite amount of detail.\n    The more you zoom in, it will never smooth out. It's likely the most well known\n    fractal in the world due to its iconic shape and how it's relatively simple to make.\n    Additionally, it's related to many other fractals ideas in math, like Julia Sets,\n    Newton's Fractal, and the bifurcation diagram. In fact, it contains copies of itself\n    and other fractals!\n</p>\n\n<br>\n<h2>How is the Mandelbrot Set Made?</h2>\n<p>\n    It makes use of a funky property of complex numbers: iteratively inputting a complex\n    number <m-el>\\(z\\)</m-el> through a rational function creates fractal results. Since\n    that's a lot to take in, we'll go over what that means. To start out, what is a\n    rational function? A rational function is simply any function that equals one polynomial\n    divided by another. For example, these are all rational functions:\n</p>\n<m-el>\\[f\\left(z\\right)=\\frac{z^{2}-3z+4}{2z^{3}-4}\\]</m-el>\n<m-el>\\[f\\left(z\\right)=\\frac{7z}{z^{5}-11z+1}\\]</m-el>\n<m-el>\\[f\\left(z\\right)=\\frac{-3z}{1}\\]</m-el>\n<p>\n    For the Mandelbrot Set, we'll use a really simple one: <m-el>\\(f\\left(z\\right)=z^{2}+c\\)</m-el>.\n    <m-el>\\(z\\)</m-el> always starts out as 0 (we'll get to what that means later) and <m-el>\\(c\\)</m-el> represents a \"seed\". This seed\n    represents a pixel on the screen you're doing the calculation for. So, the real part of the number is the x coordinate and the y\n    coordinate is the imaginary part. The fractal is actually very small, so you generally have to\n    zoom in a lot.\n</p>\n<p>\n    Secondly, \"iteratively\", in this case, means repeatedly composing the function into itself\n    multiple times. So, after one iteration, <m-el>\\(z=f\\left(z\\right)\\)</m-el>, after two iterations\n    <m-el>\\(z=f\\left(f\\left(z\\right)\\right)\\)</m-el>, after three <m-el>\\(z=f\\left(f\\left(f\\left(z\\right)\\right)\\right)\\)</m-el>,\n    and so on. Ideally, we would use an infinite amount of iterations to get a perfectly accurate Mandelbrot,\n    but that's unfortunately impossible, so we settle for a finite amount (the thumbnail image for this\n    project is actually only 25 iterations). As was said before, the starting value of <m-el>\\(z\\)</m-el>\n    will be zero, but after the first iteration, you input into the second iteration the output of the\n    first iteration. This is probably pretty hard to understand just based on the words, so let's\n    go through an example using pseudo code for a pixel, first spreading the process out and then\n    rewriting it how you probably would in a program.\n</p>\n<div class='code'>\n    <div class='code-pinline'></div>\n    <pre>\nz = 0 // z always starts out at 0\n\n// The seed. Represents the coordinates of the pixel on the screen (scaled by some amount)\nc = 0.4+0.1i\n\n// The first iteration\nz = z * z + c // z = 0.55+0.18i\n\n// The second iteration\nz = z * z + c // z = 0.6701+0.298i\n\n// Etc.\nz = z * z + c // z ≈ 0.7602+0.4994i\nz = z * z + c // z ≈ 0.7286+0.8593i\nz = z * z + c // z ≈ 0.1924+1.3521i\n</pre>\n</div>\n<p>\n    After 5 iterations, z equals about 0.1924+1.3521i. You'd find that writing that same bit of\n    code over and over again a bit cumbersome, especially if you want to do many thousands of iterations\n    so this is how you'll generally find it implemented:\n</p>\n<div class='code'>\n    <div class='code-pinline'></div>\n    <pre>\n// Same setup\nz = 0\nc = 0.4+0.1i\n\n// How many iterations will be run?\niter = 5 // In this case, five\n\n// This is equivalent to adding iter number of f() around the expression in the composition example\nrepeat iter times:\n    z = z * z + c\n\n// After five iterations, z ≈ 0.1924+1.3521i, just like how it did in the spread out example\n</pre>\n</div>\n<p>\n    So far, we've only talked about the iteration process and have vaguely mentioned\n    how it creates a fractal pattern, but how do we visualize it? There's actually many ways to visualize\n    it, but we'll go with the standard way for this article. The standard way is to draw each pixel a certain color\n    if the absolute value of <m-el>\\(z\\)</m-el> stays less than 2 (<m-el>\\(z\\)</m-el> stays <i>bounded</i>) after however many iterations you run,\n    and, if <m-el>\\(z\\)</m-el> becomes greater than 2 (<m-el>\\(z\\)</m-el> <i>escapes</i>), draw a gradient based on what iteration <m-el>\\(z\\)</m-el>\n    escapes. We do this process for every pixel on the screen with the only difference between any two pixels being the value\n    of <m-el>\\(c\\)</m-el>. If you carry out this process for every pixel on your screen, you'll get the\n    Mandelbrot set!\n</p>\n<br>\n<h2>Demo: <a href='/projects/mandelbrot/mandelbrot.html' target='_blank'>Here</a></h2>\n<br>\n<h2>Further Reading</h2>\n<ul>\n    <li>\n        <a href='https://en.wikipedia.org/wiki/Mandelbrot_set' target='_blank'>Mandelbrot Set</a> - Wikipedia.\n        Goes a lot more into the math and into the special properties of it. Very thorough.\n    </li>\n    <li>\n        <a href='https://www.youtube.com/watch?v=b005iHf8Z3g' target='_blank'>Mandelbrot Zoom Sequence</a> - Mathigon.\n        Shows the infinite complexity of the Mandelbrot and its self similarity.\n    </li>\n    <li>\n        <a href='https://www.youtube.com/watch?v=FFftmWSzgmk' target='_blank'>What's so special about the Mandelbrot Set?</a> - Numberphile.\n        Gives a very nice, gradual introduction into the Mandelbrot Set as well as Julia Sets. It focuses a\n        lot on the properties of iteration.\n    </li>\n</ul>"},"vector-motion":{"desc":"Create smooth motion used in video games","img":"/projects/vector-motion/thumbnail.png","name":"Vector Motion","html":"<h2>What is Vector Motion?</h2>\n<p>\n    Vector motion is a common technique used to create realistic smooth motion in\n    games, simulations, and anything else that requires the movement of objects to\n    look fluid. In a way, it attempts to simulate the way real world objects move\n    by using acceleration and velocity to affect the final position. There are\n    multiple ways to create vector motion and each has their own benefits and\n    detriments. These ways are called integration methods. We'll be exploring one\n    called the implicit Euler method, which is sometimes called the backward Euler\n    method. It is one of the simplest, but is also fairly accurate. It is a slight\n    variation of the more commonly taught Euler method, which is far less accurate\n    when creating simulations and requires the exact same amount of effort to create\n    as the implicit Euler method, at least how we will do it.\n</p>\n<br>\n<h2>How is it Created?</h2>\n<p>\n    Vector motion requires three parts: position, velocity, and acceleration, with each\n    being stored as a vector. In layman's terms, position is where an object is, velocity is how quickly and in what direction\n    that object is going, and acceleration is what forces are acting on it, like wind and\n    gravity (well, gravity isn't technically a force, but we'll pretend it is <i>and no\n    one will know</i>). These values are stored as vectors for simplicity when writing,\n    because, rather than doing an operation on both the x coordinate and the y coordinate, you can\n    simply do a single operation on a vector. gain in layman's terms, the integration method essentially\n    dictates how acceleration affects velocity and how velocity affects position as\n    time goes on. The implicit Euler method simply says to add the acceleration to the\n    velocity and then add velocity to the position, with both acceleration and velocity\n    scaled by the time step. In fancy math notation, that would be <m-el>\\(\\vec{v}=\\vec{v}+\\vec{a}t\\)</m-el>\n    and then <m-el>\\(\\vec{p}=\\vec{p}+\\vec{v}t\\)</m-el> (so fancy!).\n    <m-el>\\(\\vec{a}\\)</m-el> is the acceleration, <m-el>\\(\\vec{v}\\)</m-el> is the\n    velocity, <m-el>\\(\\vec{p}\\)</m-el> is the position, and <m-el>\\(t\\)</m-el> is the\n    time step.\n</p>\n<p>\n    For the uninitiated, time steps can be a bit odd to think about, so we'll go over\n    what they are. In the ideal math world, we'd run our integration method to update\n    the position, velocity, and acceleration an infinite amount of times per second,\n    but the real world is harsh and cruel, so we don't get our way. We can only run\n    our integration method a finite amount of times per second. If you were to run\n    the integration method 10 times per second, objects would move at a certain speed,\n    but if you wanted to run the integration method 20 times per second, objects\n    would suddenly have their position be updated twice as much per second, which means\n    they would move twice as much in the same amount of time, which is not what we want. Time steps account\n    for this. In the original scenario with 10 iterations per second, the time step\n    might be 1, but in the 20 iterations scenario, the time step would be 0.5, and\n    therefore, the changes to the acceleration and velocity would be half as large. That\n    means that, even though objects would be updated twice as often, those updates\n    would be twice as small, which causes the speed to stay the same! You might wonder\n    when this would ever be needed, and the answer is quite often. As a real world example, the frame rate of\n    any program, including games, is actually quite variable and lag spikes can occur. When\n    the frame rate changes, you don't want the program to become significantly slower,\n    because that would feel unnatural and annoying to the user. Additionally, all\n    integration methods are slightly inaccurate due to the fact that we have to use\n    a finite number of interations per second, but making the time step smaller\n    makes that inaccuracy smaller. So, if accuracy matters, being able to change\n    the time step also matters.\n</p>\n<p>\n    Now that we have time steps covered, let's go on to how vector\n    motion is used. In games with user input, the player's inputs\n    often only directly affect acceleration. When the player presses\n    an input to go right, the x component of the acceleration vector\n    would be set to a positive value, causing the velocity vector's\n    x component to gradually become positive. You can do the opposite\n    for when the player presses an input to go left. You don't often\n    want to directly change the velocity based on the player's inputs\n    because it will make the motion feel jerky. However, you do often\n    want to place some limits on the velocity like preventing it from\n    getting too large and making it smaller if the player isn't pressing\n    any inputs. In simulations, you'll often have some sort of equation for the acceleration\n    and you can just set the acceleration to that equation. You generally don't\n    want to set limits for simulations since that isn't physically accurate.\n</p>\n<br>\n<h2>Demo: <a href='/projects/vector-motion/vector-motion.html' target='_blank'>Here</a></h2>\n<p>\n    Use the W, A, S, and D keys or the arrow keys to move around. The velocity and acceleration vectors,\n    their corresponding values, and the speed of the player are shown in the top left.\n</p>\n<br>\n<h2>Helpful Tips</h2>\n<ul>\n    <li>\n        During large lag spikes in games, the time step can get very large. When that happens,\n        there are often a lot of glitches that you don't want, so you can limit the\n        size of the time step to prevent those glitches from happening.\n    </li>\n</ul>\n<br>\n<h2>Further Reading</h2>\n<ul>\n    <li>\n        <a href='https://en.wikipedia.org/wiki/Numerical_integration' target='_blank'>Numerical integration</a> - wikipedia.\n        This Codec article (the one you're currently reading) simplifies the idea of integration methods a lot. This Wikipedia article\n        goes over the actual calculus and general math used in integration.\n    </li>\n    <li>\n        <a href='https://www.khanacademy.org/computing/computer-programming/programming-natural-simulations/programming-vectors/a/vector-motion' target='_blank'>Vector Motion</a> - Khan Academy.\n        A breif article about how vector motion works using JavaScript and the ProcessingJS library.\n    </li>\n    <li>\n        <a href='https://en.wikipedia.org/wiki/Backward_Euler_method' target='_blank'>Backward Euler method</a> - Wikipedia.\n        Details the math of the implicit Euler method.\n    </li>\n    <li>\n        <a href='https://en.wikipedia.org/wiki/Euler_method' target='_blank'>Euler method</a> - Wikipedia.\n        Goes over the explicit Euler method and its inaccuracy.\n    </li>\n</ul>"},"verlet-integration":{"desc":"A simple technique to create realistic physics","img":"/projects/verlet-integration/thumbnail.png","name":"Verlet Integration","html":"<p class='center'>\n    This article builds off of the ideas presented in <a href='/projects/?p=vector-motion'>Vector Motion</a>.\n    It's suggested that you read that article before continuing.\n</p>\n<br>\n<h2>What is Verlet Integration?</h2>\n<p>\n    Verlet integration is another integration method, but it has a property which\n    makes it a very good choice for simple physics simulations. That property is\n    that it automatically handles velocity redirection. What does that jargin I\n    just created mean? Think about a Magic 8 Ball, majestically floating above a\n    hill. You ask it your fate, but it does not want to answer, because it knows\n    you will not like it. It subjects itself to the will of physics, and drops\n    straight down. As it hits the hill side, it does not fall through the hill,\n    but rather, it rolls along the surface of the hill. The velocity of the ball\n    was redirected from going straight down to going at an angle. In a physics\n    simulation with Euler integration, you have to redirect the velocity in\n    addition to doing other things. With Verlet integration, that redirection is\n    a byproduct of doing those other things. How nice! This simplifies the\n    calculations significantly, making many projects, like cloth simulations\n    much easier. Verlet integration isn't the most accurate, so it's good for\n    visuals, but not for highly accurate simulations.\n</p>\n<br>\n<h2>How is it Created?</h2>\n<p>\n    The main difference between Verlet integration and many other methods is that it\n    doesn't keep trace of an object's velocity. Instead, it keeps track of the\n    previous position. Since the velocity is simply the difference in positions,\n    it can be calculated by subtracing the previous position from the current one.\n    You can add forces like gravity by adding it to the velocity at this step.\n    After this, simply set the previous position to the current position and add the velocity\n    to the current position. That's it! However, the benefits of Verlet integration\n    won't be apparent if you just implement this; it'll look the exact same as\n    the implicit Euler method.\n</p>\n<br>\n<h2>Creating a Demo</h2>\n<p>\n    One of the easiest ways to show the wonders of Verlet integration is to make\n    a simple physics simulation of balls interacting with each other and rolling\n    around. One such simulation can be found\n    <a href='/projects/verlet-integration/verlet-integration.html' target='_blank'>here</a> (click\n    to pause and move your mouse to control a ball). Verlet integration already handles\n    the movement caused by gravity if you add it as a force, like mentioned before.\n    The next thing to do is to create a boundary so the balls don't fall out of sight.\n    To do this, simply check is past the barrier, and if so, move its position to the\n    closest point that is within the boundary. Verlet integration takes care of making\n    sure that the ball starts to roll in the correct direction automatically. Having\n    a singular ball is a bit unexciting, so adding more balls is a good idea. At this\n    point in time, all of the balls with phase through each other. In order to make\n    the balls interact, check if any two balls are intersecting. If any are, find out\n    how much they overlap and move them each away from each other by half of the distance\n    they overlap each other (each moving them by half ends up moving them so they touch\n    without overlapping. If the half part still seems a bit weird, remember that moving\n    one ball half of the overlapping distance in one direction and the other ball the\n    other half in the opposite direction is equivalent to <m-el>\\(0.5+0.5=1\\)</m-el>).\n</p>\n<p>\n    For small numbers of balls, this current method will work well; however, adding\n    more balls will cause the balls to sink into each other, because, though the collision\n    code for balls will prevent any two balls from overlapping, the corrections can push\n    a ball into another ball. This sinking effect generally looks fairly odd. To get rid\n    of it, all you have to do is check all of the intersections multiple times. Each pass,\n    each ball will find a position that overlaps with its neighbors less and less.\n    This is all of it! You never have to touch the velocity when doing the collisions. All of\n    it is handled automatically.\n</p>\n<br>\n<h2>Further Reading</h2>\n<ul id = 'further-reading-list'>\n    <li>\n        <a href='https://www.youtube.com/watch?v=3HjO_RGIjCU' target='_blank'>Verlet Integration Part I</a> - Coding Math.\n        The start of a series which covers Verlet integration and how to create\n        more advanced physics simulations.\n    </li>\n    <li>\n        <a href='https://en.wikipedia.org/wiki/Verlet_integration' target='_blank'>Verlet integration</a> - Wikipedia.\n        Thoroughly covers the mathematics.\n    </li>\n</ul>"}}